
"==========================================
" FileEncode Settings 文件编码,格式
"==========================================
" 自动判断编码时，依次尝试以下编码：
set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1
set helplang=cn
"set langmenu=zh_CN.UTF-8
"set enc=2byte-gb18030
" 下面这句只影响普通模式 (非图形界面) 下的 Vim。
set termencoding=utf-8
" 设置输入法在普通模式下无效
set noimdisable
autocmd! InsertLeave * set imdisable|set iminsert=0
autocmd! InsertEnter * set noimdisable|set iminsert=0
" Use Unix as the standard file type
set ffs=unix,dos,mac

" 如遇Unicode值大于255的文本，不必等到空格再折行。
set formatoptions+=m
" 合并两行中文时，不在中间加空格：
set formatoptions+=B

"设置 退出vim后，内容显示在终端屏幕, 可以用于查看和复制
"好处：误删什么的，如果以前屏幕打开，可以找回
"set t_ti= t_te=

" 00x增减数字时使用十进制
set nrformats=

set nospell
" not set autochdir, use ,cd when you want to change PWD
nnoremap <leader>cd :cd %:p:h<CR>:pwd<CR>

" fix location window report: E924: Current window was closed
let g:syntastic_auto_loc_list = 3

"set default color schema    
colorscheme molokai

" Set extra options when running in GUI mode
if has("gui_running")
    set guioptions-=T
    set guioptions+=e
    set t_Co=256
    set guitablabel=%M\ %t
else
	" 设置标记一列的背景颜色和数字一行颜色一致
	hi! link SignColumn   LineNr
	hi! link ShowMarksHLl DiffAdd
	hi! link ShowMarksHLu DiffChange

	" for error highlight，防止错误整行标红导致看不清
	highlight clear SpellBad
	highlight SpellBad term=standout ctermfg=1 term=underline cterm=underline
	highlight clear SpellCap
	highlight SpellCap term=underline cterm=underline
	highlight clear SpellRare
	highlight SpellRare term=underline cterm=underline
	highlight clear SpellLocal
	highlight SpellLocal term=underline cterm=underline
endif

" quickfix window  s/v to open in split window,  ,gd/,jd => quickfix window => open it
autocmd BufReadPost quickfix nnoremap <buffer> v <C-w><Enter><C-w>L
autocmd BufReadPost quickfix nnoremap <buffer> s <C-w><Enter><C-w>K

" 打开自动定位到最后编辑的位置, 需要确认 .viminfo 当前用户可写
if has("autocmd")
  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
endif

" NOT to use spaces instead of tabs
set noexpandtab

" ================ 行号 ============================
" 相对行号      行号变成相对，可以用 nj  nk   进行跳转 5j   5k 上下跳5行
" if v:version >= 703
" set relativenumber number
" au FocusLost * :set norelativenumber number
" au FocusGained * :set relativenumber
" " 插入模式下用绝对行号, 普通模式下用相对
" autocmd InsertEnter * :set norelativenumber number
" autocmd InsertLeave * :set relativenumber
" function! NumberToggle()
"     if(&relativenumber == 1)
"         set norelativenumber number
"     else
"         set relativenumber
"     endif
" endfunc
" nnoremap <leader>on: call NumberToggle()<cr>

""为方便复制，用于开启/关闭行号显示:
" function! HideNumber()
"   if(&relativenumber == &number)
"     set relativenumber! number!
"   elseif(&number)
"     set number!
"   else
"     set relativenumber!
"   endif
"   set number?
" endfunc
" nnoremap <leader>hn :call HideNumber()<CR>
" endif

nnoremap <leader>ol :set list! list?<CR>
nnoremap <leader>ow :set wrap! wrap?<CR>
" ================ Search format ============================
" 进入搜索Use sane regexes"
nnoremap / /\v
vnoremap / /\v

"Keep search pattern at the center of the screen."
nnoremap <silent> n nzz
nnoremap <silent> N Nzz
nnoremap <silent> * *zz
nnoremap <silent> # #zz
nnoremap <silent> g* g*zz


"Switch line down/up key for wrapper line, default is overwrite 
nnoremap gj j
nnoremap gk k

" http://stackoverflow.com/questions/13194428/is-better-way-to-zoom-windows-in-vim-than-zoomwin
" Zoom / Restore window.
function! s:ZoomToggle() abort
    if exists('t:zoomed') && t:zoomed
        execute t:zoom_winrestcmd
        let t:zoomed = 0
    else
        let t:zoom_winrestcmd = winrestcmd()
        resize
        vertical resize
        let t:zoomed = 1
    endif
endfunction
command! ZoomToggle call s:ZoomToggle()
nnoremap <silent> <Leader>z :ZoomToggle<CR>

" toggle wrap mode, similar to [ow/]ow in plugin vim-unimpaired 
:nmap <leader>ow :setlocal wrap!<CR> :setlocal wrap? <CR>

"离开插入模式后自动关闭预览窗口
autocmd InsertLeave * if pumvisible() == 0|pclose|endif
"回车即选中当前项
inoremap <expr> <CR>       pumvisible() ? "\<C-y>" : "\<CR>"

"上下左右键的行为 会显示其他信息
inoremap <expr> <Down>     pumvisible() ? "\<C-n>" : "\<Down>"
inoremap <expr> <Up>       pumvisible() ? "\<C-p>" : "\<Up>"
inoremap <expr> <PageDown> pumvisible() ? "\<PageDown>\<C-p>\<C-n>" : "\<PageDown>"
inoremap <expr> <PageUp>   pumvisible() ? "\<PageUp>\<C-p>\<C-n>" : "\<PageUp>"

" disable store option for scrollbind setting problem
" restore_view.vim {
	if isdirectory(expand("~/.vim/bundle/restore_view.vim/"))
		set viewoptions=cursor,folds,slash,unix 
	endif
" }
" indentLine {
	if isdirectory(expand("~/.vim/bundle/indentLine/"))
        let g:indentLine_color_term = 239
        "let g:indentLine_color_gui = '#A4E57E'
        "let g:indentLine_color_tty_light = 7 " (default: 4)
        "let g:indentLine_color_dark = 1 " (default: 2)
        "let g:indentLine_char = '¦'
    endif
" }
" vim-airline {
	if isdirectory(expand("~/.vim/bundle/vim-airline/"))
		" do not display trailing/mixed-indent/mixed-indent-file
		let g:airline#extensions#whitespace#enabled = 0
		if !exists('g:airline_symbols')
    		let g:airline_symbols = {}
		endif
        " unicode symbols
        "let g:airline_left_sep = '▶'
        let g:airline_left_sep = '»'
        "let g:airline_right_sep = '◀'
        let g:airline_right_sep = '«'
        "let g:airline_symbols.linenr = '␊'
        "let g:airline_symbols.linenr = '¶'
        let g:airline_symbols.linenr = '␤'
        let g:airline_symbols.branch = '⎇'
        "let g:airline_symbols.paste = 'ρ'
        let g:airline_symbols.paste = 'Þ'
        "let g:airline_symbols.paste = '∥'
        let g:airline_symbols.whitespace = 'Ξ'
    endif
" }
" cscope {
	if isdirectory(expand("~/.vim/bundle/cscope.vim"))
        let g:cscope_silent = 1
        nnoremap <leader>fa :call CscopeFindInteractive(expand('<cword>'))<CR>
        nnoremap <leader>l :call ToggleLocationList()<CR>

		nnoremap  <leader>fs :call CscopeFind('s', expand('<cword>'))<CR>
		nnoremap  <leader>fg :call CscopeFind('g', expand('<cword>'))<CR>
		nnoremap  <leader>fd :call CscopeFind('d', expand('<cword>'))<CR>
		nnoremap  <leader>fc :call CscopeFind('c', expand('<cword>'))<CR>
		nnoremap  <leader>ft :call CscopeFind('t', expand('<cword>'))<CR>
		nnoremap  <leader>fe :call CscopeFind('e', expand('<cword>'))<CR>
		nnoremap  <leader>ff :call CscopeFind('f', expand('<cword>'))<CR>
		nnoremap  <leader>fi :call CscopeFind('i', expand('<cword>'))<CR>
	endif
" }

" cscope_dynamic {
    if isdirectory(expand("~/.vim/bundle/cscope_dynamic"))
        let g:statusline_cscope_flag = ""
        set statusline=[%n]%<%f\ %h%m%r\ %=\
        set statusline+=%(\ [%{g:statusline_cscope_flag}]\ \ \ %)
        set statusline+=%-14.(%l,%c%V%)\ %P
        
        function! Cscope_dynamic_update_hook(updating)
            if a:updating
                let g:statusline_cscope_flag = "C"
            else
                let g:statusline_cscope_flag = ""
            endif
            execute "redrawstatus!"
        endfunction
        call Cscope_dynamic_update_hook(0)

        nmap <F11> <Plug>CscopeDBInit
        
        setlocal noautochdir 
        "set csto=0
        "set cst				    "search both of scope and tag file
        "set nocsverb                            "no verbose
        "set cscopequickfix=s-,c-,d-,i-,t-,e-    "output to QuickFix window
        "Change cscope output to quickfix window or not.

		function! s:cscopeChangeOutput()
		    if &cscopequickfix != 's+,c+,d+,i+,t+,e+'
        		set cscopequickfix=s+,c+,d+,i+,t+,e+
		        echo "cscope Quickfix mode is ".&cscopequickfix
		    elseif &cscopequickfix == 's+,c+,d+,i+,t+,e+'
		    	set cscopequickfix=""
		        echo "cscope Quickfix mode is Off."
		    endif
		endfunction
        nmap <silent><leader>fo :call <SID>cscopeChangeOutput()<CR>  " toggle output
        
        nmap <leader>fs :cs find s <C-R>=expand("<cword>")<CR><CR>	
    	nmap <leader>fg :cs find g <C-R>=expand("<cword>")<CR><CR>	
    	nmap <leader>fc :cs find c <C-R>=expand("<cword>")<CR><CR>	
    	nmap <leader>ft :cs find t <C-R>=expand("<cword>")<CR><CR>	
    	nmap <leader>fe :cs find e <C-R>=expand("<cword>")<CR><CR>	
    	nmap <leader>ff :cs find f <C-R>=expand("<cfile>")<CR><CR>	
    	nmap <leader>fi :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
    	nmap <leader>fd :cs find d <C-R>=expand("<cword>")<CR><CR>
    
    endif
" }
" vim-easytags {
    if isdirectory(expand("~/.vim/bundle/vim-easytags"))
        let g:easytags_dynamic_files = 1
        let g:easytags_file = '~/.vim/tags'
        let g:easytags_async = 1
        let g:easytags_autorecurse = 1
        let g:easytags_include_members = 1
        let g:easytags_resolve_links = 0
	let g:easytags_auto_update = 0
	let g:easytags_auto_highlight = 0
        let g:easytags_events = ['BufWritePost']
	let g:easytags_on_cursorhold = 0
    endif
" }
" NerdTree {
    if isdirectory(expand("~/.vim/bundle/nerdtree"))
        let NERDTreeIgnore+=[ '\.pyo$', '\.obj$', '\.o$', '\.so$']
    endif
" }

" SrcExpl {
	if isdirectory(expand("~/.vim/bundle/SrcExpl/"))
		nmap <leader>se :SrcExplToggle<CR> 

		let g:SrcExpl_winHeight = 8 
		let g:SrcExpl_refreshTime = 100 
		let g:SrcExpl_searchLocalDef = 1 
		let g:SrcExpl_isUpdateTags = 0 

		let g:SrcExpl_jumpKey = "<ENTER>" 
		let g:SrcExpl_gobackKey = "<SPACE>" 
		let g:SrcExpl_updateTagsKey = "<F11>u" 
		let g:SrcExpl_prevDefKey = "<F11>b" 
		let g:SrcExpl_nextDefKey = "<F11>f" 
		"
		" // In order to avoid conflicts, the Source Explorer should know what plugins " 
		" // except itself are using buffers. And you need add their buffer names into " 
		" // below listaccording to the command ":buffers!"                            " 
		 let g:SrcExpl_pluginList = [ 
				 \ "__Tag_List__", 
				 \ "__Tagbar__", 
				 \ "NERD_tree_",
				 \ "Quickfix List" 
			 \ ] 
		"                                                                              " 
		" // Use 'Exuberant Ctags' with '--sort=foldcase -R .' or '-L cscope.files' to " 
		" //  create/update a tags file                                                " 
		let g:SrcExpl_updateTagsCmd = "ctags --sort=foldcase -R ." 
	endif
" }

" Because CtrlP, YankRing and vim-multiple-cursors use Ctrl+P, we need to remap
" YankRing{
    if isdirectory(expand("~/.vim/bundle/YankRing.vim"))
        let yankring_min_element_length=4
        let g:yankring_history_file = '.yankring-history'
        nnoremap <leader>yr :YRShow<CR>
    endif
" }

" CtrlP{
    if isdirectory(expand("~/.vim/bundle/ctrlp.vim"))
        let g:ctrlp_by_filename = 1
        nnoremap <leader>cp :CtrlP<CR>
        nnoremap <leader>bl :CtrlPBuffer<CR>
    endif
" }
" CtrlP-funky{
    if isdirectory(expand("~/.vim/bundle/ctrlp-funky/"))
        nnoremap <Leader>fu :CtrlPFunky<Cr>
        nnoremap <Leader>fU :execute 'CtrlPFunky ' . expand('<cword>')<Cr>
    endif
" }
" vim-mark {
	if isdirectory(expand("~/.vim/bundle/vim-mark/"))
		"Unmap '<leader>/' because of '<leader>/' key use in SPF13 conflict with vim-mark plugins
		nunmap <silent> <leader>/
		"remove the default overriding of * and #, use: 
    	nmap <Plug>IgnoreMarkSearchNext <Plug>MarkSearchNext 
    	nmap <Plug>IgnoreMarkSearchPrev <Plug>MarkSearchPrev 
	endif
" }

"YouCompleteMe{
	if count(g:spf13_bundle_groups, 'youcompleteme') 
		if !empty(glob("~/.ycm_extra_conf.py"))
			let g:ycm_global_ycm_extra_conf = "~/.ycm_extra_conf.py"
		elseif !empty(glob("~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py"))
    		let g:ycm_global_ycm_extra_conf = "~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py"
		endif   
        let g:ycm_confirm_extra_conf=0
        let g:ycm_min_num_of_chars_for_completion = 1
        let g:ycm_auto_trigger = 1
		" 跳转到定义处, 分屏打开
		let g:ycm_goto_buffer_command = 'horizontal-split'
        " speedup: YCM + Syntastic with gcc 
        "g:ycm_register_as_syntastic_checker = 0

		nnoremap <leader>jw :YcmCompleter GoTo<CR>
		nnoremap <leader>jd :YcmCompleter GoToDefinition<CR>
		nnoremap <leader>js :YcmCompleter GoToDeclaration<CR>
		nnoremap <leader>jt :YcmCompleter GetType<CR>
		nnoremap <leader>jh :YcmCompleter GetParent<CR>
		
	endif
"}

" if this not work ,make sure .viminfo is writable for you
if has("autocmd")
    au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
endif

" Map ; to : and save a million keystrokes
" ex mode commands made easy 用于快速进入命令行
nnoremap ; :

" Make 0 go to the first character rather than the beginning
" of the line. When we're programming, we're almost always
" interested in working with text rather than empty space. If
" you want the traditional beginning of line, use ^
nnoremap 0 ^
nnoremap ^ 0

" Quickly edit/reload the vimrc file
nnoremap <silent> <leader>ev :e  $MYVIMRC<CR>
nnoremap <silent> <leader>sv :so $MYVIMRC<CR>

" 定义函数AutoSetFileHead，自动插入文件头
autocmd BufNewFile *.sh,*.py exec ":call AutoSetFileHead()"
function! AutoSetFileHead()
    "如果文件类型为.sh文件
    if &filetype == 'sh'
        call setline(1, "\#!/bin/bash")
    endif

    "如果文件类型为python
    if &filetype == 'python'
        call setline(1, "\#!/usr/bin/env python")
        call append(1, "\# encoding: utf-8")
    endif

    normal G
    normal o
    normal o
endfunc

" F10 to run python script
nnoremap <buffer> <F10> :exec '!python' shellescape(@%, 1)<cr>

" save
cmap w!! w !sudo tee >/dev/null %

" command mode, ctrl-a to head， ctrl-e to tail
cnoremap <C-j> <t_kd>
cnoremap <C-k> <t_ku>
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
"==========================================
" Search in visual model
"==========================================
function! CmdLine(str)
    exe "menu Foo.Bar :" . a:str
    emenu Foo.Bar
    unmenu Foo
endfunction

function! VisualSelection(direction, extra_filter) range
    let l:saved_reg = @"
    execute "normal! vgvy"

    let l:pattern = escape(@", '\\/.*$^~[]')
    let l:pattern = substitute(l:pattern, "\n$", "", "")

    if a:direction == 'b'
        execute "normal ?" . l:pattern . "^M"
    elseif a:direction == 'gv'
        call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.' . a:extra_filter)
    elseif a:direction == 'replace'
        call CmdLine("%s" . '/'. l:pattern . '/')
    elseif a:direction == 'f'
        execute "normal /" . l:pattern . "^M"
    endif

    let @/ = l:pattern
    let @" = l:saved_reg
endfunction

" Visual mode pressing * or # searches for the current selection
" Super useful! From an idea by Michael Naumann
vnoremap <silent> * :call VisualSelection('f', '')<CR>
vnoremap <silent> # :call VisualSelection('b', '')<CR>
" When you press <leader>vr you can search and replace the selected text
vnoremap <silent> <leader>vr :call VisualSelection('replace', '')<CR>

"==========================================
" Automatically jump to a file at the correct line number
"==========================================
" i.e. if your cursor is over /some/path.rb:50 then using 'gf' on it will take
" you to that line

" use ,gf to go to file in a vertical split
nnoremap <silent> <leader>gf   :vertical botright wincmd f<CR>

" use to jump to tag definition in a vertical split, similar to horizon split: <C-w>]
nnoremap <silent> <leader>w] :vsp <CR>:exec("tag ".expand("<cword>"))<CR>
nnoremap <silent> <leader>t] :tab split<CR>:exec("tag ".expand("<cword>"))<CR>
"==========================================
" quickfix-search
"==========================================
" Stolen from Steve Losh vimrc: https://bitbucket.org/sjl/dotfiles/src/tip/vim/.vimrc
" Open a Quickfix window for the last search. similar to query search history: q/
nnoremap <silent> <leader>q/ :execute 'vimgrep /'.@/.'/g %'<CR>:copen<CR>

" Ag/Ack for the last search.
nnoremap <silent> <leader>qa/ :execute "Ack! '" . substitute(substitute(substitute(@/, "\\\\<", "\\\\b", ""), "\\\\>", "\\\\b", ""), "\\\\v", "", "") . "'"<CR>
"==========================================
" Use Q to intelligently close a window
"==========================================
" (if there are multiple windows into the same buffer)
" or kill the buffer entirely if it's the last window looking into that buffer
function! CloseWindowOrKillBuffer()
    let number_of_windows_to_this_buffer = len(filter(range(1, winnr('$')), "winbufnr(v:val) == bufnr('%')"))

    " We should never bdelete a nerd tree
    if matchstr(expand("%"), 'NERD') == 'NERD'
        wincmd c
        return
    endif

    if number_of_windows_to_this_buffer > 1
        wincmd c
    else
        bdelete
    endif
endfunction

nnoremap <silent> Q :call CloseWindowOrKillBuffer()<CR>

"==========================================
" better tracking my usage of the <leader> namespace for my key mappings
"==========================================
function! ListLeaders()
    silent! redir @a
    silent! nmap <LEADER>
    silent! redir END
    silent! new
    silent! put! a
    silent! g/^s*$/d
    silent! %s/^.*,/,/
    silent! normal ggVG
    silent! sort
    silent! let lines = getline(1,"$")
endfunction
nnoremap <silent> <leader>ll :call ListLeaders()<CR> 
